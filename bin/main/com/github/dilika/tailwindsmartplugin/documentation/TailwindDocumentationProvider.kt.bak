package com.github.dilika.tailwindsmartplugin.documentation

import com.github.dilika.tailwindsmartplugin.services.TailwindConfigService
import com.github.dilika.tailwindsmartplugin.utils.TailwindUtils
import com.intellij.lang.documentation.AbstractDocumentationProvider
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.project.Project
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiLanguageInjectionHost
import com.intellij.psi.xml.*
import org.jetbrains.kotlin.psi.psiUtil.parents
import org.json.JSONObject

/**
 * Provides documentation for Tailwind CSS classes.
 * This provider is designed to override other documentation providers when Tailwind classes are detected.
 */
@Suppress("unused") // Registered via plugin.xml
class TailwindDocumentationProvider : AbstractDocumentationProvider() {
    private val logger = Logger.getInstance(TailwindDocumentationProvider::class.java)
    private val enhancedDocumentation = TailwindEnhancedDocumentation()

    /**
     * Override getQuickNavigateInfo to ensure Tailwind documentation is prioritized
     * This method is called first for quick documentation display
     */
    /**
     * Critical method that allows us to override the element that will receive documentation.
     * This is the key to getting Tailwind class documentation to appear when hovering inside className values.
     */
    override fun getCustomDocumentationElement(editor: com.intellij.openapi.editor.Editor, file: com.intellij.psi.PsiFile, contextElement: PsiElement?, targetOffset: Int): PsiElement? {
        try {
            this.logger.info("\n=== getCustomDocumentationElement ====")
            this.logger.info("File: ${file.virtualFile?.path ?: file.name}")
            this.logger.info("File type: ${file.fileType.name}")
            this.logger.info("Element type: ${contextElement?.javaClass?.name}")
            this.logger.info("Element text: '${contextElement?.text?.take(100)}'")
            this.logger.info("Element parent: ${contextElement?.parent?.javaClass?.name}")
            this.logger.info("Element text range: ${contextElement?.textRange}")
            this.logger.info("Target offset: $targetOffset")
            
            // Dump the element hierarchy for debugging
            var current: PsiElement? = contextElement
            var indent = 0
            while (current != null) {
                this.logger.info("${"  ".repeat(indent)}- ${current.javaClass.name}: '${current.text.take(50)}'")
                current = current.parent
                indent++
            }
            
            // Log the text around the cursor for better context
            var wordAtCursor: String? = null
            try {
                val document = editor.document
                val lineNumber = document.getLineNumber(targetOffset)
                val lineStart = document.getLineStartOffset(lineNumber)
                val lineEnd = document.getLineEndOffset(lineNumber)
                val lineText = document.getText(com.intellij.openapi.util.TextRange(lineStart, lineEnd))
                this.logger.info("Line $lineNumber: $lineText")
                
                // Get the word at cursor position
                val text = document.charsSequence
                var start = targetOffset
                var end = targetOffset
                
                // Find the start of the current word
                while (start > 0 && isTailwindWordChar(text[start - 1])) {
                    start--
                }
                
                // Find the end of the current word
                while (end < text.length && isTailwindWordChar(text[end])) {
                    end++
                }
                
                if (start < end) {
                    wordAtCursor = text.subSequence(start, end).toString()
                    this.logger.info("Extracted word at cursor: '$wordAtCursor'")
                }
            } catch (e: Exception) {
                this.logger.warn("Error getting cursor context: ${e.message}")
            }
            
            if (contextElement == null) {
                this.logger.info("Context element is null, exiting")
                return null
            }
            
            // Check if we're in a class or className attribute
            val isClassAttribute = when (contextElement) {
                is XmlAttributeValue -> {
                    val attr = contextElement.parent.firstChild?.text?.lowercase()
                    attr == "class" || attr == "classname"
                }
                else -> false
            }
            
            this.logger.info("Is class attribute: $isClassAttribute")
            
            // If we have a word at cursor and it looks like a Tailwind class, use it
            if (!wordAtCursor.isNullOrEmpty() && isTailwindPattern(wordAtCursor, file.project)) {
                this.logger.info("Using word at cursor as Tailwind class: '$wordAtCursor'")
                contextElement.putUserData(TAILWIND_CLASS_KEY, wordAtCursor)
                return contextElement
            }
            
            // Check for HTML/JSX/XML attribute values
            if (contextElement is XmlAttributeValue) {
                val attribute = contextElement.parent
                val attrName = attribute?.firstChild?.text?.lowercase()
                this.logger.info("Found XML attribute value with name: $attrName")
                
                if (attrName == "class" || attrName == "className") {
                    // Get the attribute value text
                    val attrValue = contextElement.value
                    this.logger.info("Attribute value: '$attrValue'")
                    
                    if (attrValue.isNotBlank()) {
                        // Calculate cursor offset within the attribute value
                        val relativeOffset = targetOffset - contextElement.textRange.startOffset
                        this.logger.info("Relative offset within value: $relativeOffset")
                        
                        // Find the class at cursor position
                        val className = findClassAtCursor(attrValue, relativeOffset)
                        this.logger.info("Class at cursor: $className")
                        
                        if (className != null && isTailwindPattern(className, file.project)) {
                            this.logger.info("Found valid Tailwind class: '$className'")
                            contextElement.putUserData(TAILWIND_CLASS_KEY, className)
                            return contextElement
                        }
                    }
                }
            }
            
            // JavaScript string literals that could be class names
            if (contextElement is com.intellij.psi.PsiLiteralExpression || 
                contextElement.javaClass.name.contains("JSLiteralExpression")) {
                val literalText = contextElement.text.trim()
                this.logger.info("Found literal: $literalText")
                
                // Extract potential class names from string literals
                val cleanText = literalText.removeSurrounding("\"").removeSurrounding("'")
                if (cleanText.contains(" ")) {
                    // This could be multiple classes - check if cursor is on a specific class
                    val relativeOffset = targetOffset - contextElement.textRange.startOffset - 1 // Adjust for quotes
                    this.logger.info("Literal contains spaces, checking class at offset $relativeOffset")
                    
                    if (relativeOffset >= 0 && relativeOffset < cleanText.length) {
                        val className = findClassAtCursor(cleanText, relativeOffset)
                        if (className != null && isTailwindPattern(className, file.project)) {
                            this.logger.info("Found Tailwind class in literal: $className")
                            contextElement.putUserData(TAILWIND_CLASS_KEY, className)
                            return contextElement
                        }
                    }
                } else if (isTailwindPattern(cleanText, file.project) && cleanText.length < 50) {
                    // Single class literal
                    this.logger.info("Found single Tailwind class: $cleanText")
                    contextElement.putUserData(TAILWIND_CLASS_KEY, cleanText)
                    return contextElement
                }
            }
            
            // For any other text that might be a Tailwind class
            val text = contextElement.text.trim()
            if (text.isNotBlank() && !text.contains(" ") && !text.contains("\n") && 
                text.length < 50) {
                
                val className = text.removeSurrounding("\"").removeSurrounding("'")
                if (isTailwindPattern(className, file.project)) {
                    this.logger.info("Found direct Tailwind class: $className")
                    contextElement.putUserData(TAILWIND_CLASS_KEY, className)
                    return contextElement
                }
            }
            
            this.logger.info("No Tailwind class found, returning null")
            return null
        } catch (e: Exception) {
            this.logger.error("Error in getCustomDocumentationElement: ${e.message}")
            e.printStackTrace()
            return null
        }
    }
    
    // Key for storing Tailwind class name in element user data
    private val TAILWIND_CLASS_KEY = com.intellij.openapi.util.Key<String>("TAILWIND_CLASS_NAME")
    
    /**
     * Checks if a character is valid in a Tailwind class name
     */
    private fun isTailwindWordChar(c: Char): Boolean {
        return c.isLetterOrDigit() || c == '-' || c == ':' || c == '[' || c == ']' || c == '.' || c == '/' || c == '#'
    }
    
    /**
     * Helper method to check if an element is a className attribute
     */
    private fun isClassNameAttribute(element: PsiElement): Boolean {
        // Check if this is a className attribute or its value
        return element.text == "className" || 
               element.parent?.firstChild?.text == "className" ||
               element.text.contains("className=")
    }
    
    override fun getQuickNavigateInfo(element: PsiElement?, originalElement: PsiElement?): String? {
        this.logger.info("=========================")
        this.logger.info("getQuickNavigateInfo called for element: ${element?.text}, originalElement: ${originalElement?.text}")
        this.logger.info("Element class: ${element?.javaClass?.name}, Original element class: ${originalElement?.javaClass?.name}")
        this.logger.info("Parent: ${element?.parent?.javaClass?.name}, Parent text: ${element?.parent?.text?.take(50)}")
        this.logger.info("=========================")
        
        // Check for Tailwind class key in user data (from getCustomDocumentationElement)
        val tailwindClass = element?.getUserData(TAILWIND_CLASS_KEY)
        if (tailwindClass != null) {
            this.logger.info("Found Tailwind class in user data: $tailwindClass")
            return generateDocForClass(tailwindClass, element.project)
        }
        
        // Check for className attribute
        val classNameResult = handleClassNameAttribute(element, originalElement)
        if (classNameResult != null) {
            this.logger.info("Generated quick doc from className attribute")
            return classNameResult
        }
        
        // Try direct text-based documentation next
        val directResult = generateDirectTailwindDoc(element, originalElement)
        if (directResult != null) {
            this.logger.info("Direct documentation generated successfully")
            return directResult
        }
        
        // Fall back to normal document generation
        val result = generateTailwindDoc(element, originalElement)
        this.logger.info("getQuickNavigateInfo result: ${result != null}")
        return result
    }
    
    /**
     * Main documentation generation method
     */
    override fun generateDoc(element: PsiElement?, originalElement: PsiElement?): String? {
        this.logger.info("\n=== generateDoc ===")
        this.logger.info("Element: ${element?.text?.take(50)}")
        this.logger.info("Element type: ${element?.javaClass?.name}")
        this.logger.info("Original element: ${originalElement?.text?.take(50)}")
        this.logger.info("Original element type: ${originalElement?.javaClass?.name}")
        
        try {
            // Check for Tailwind class key in user data (from getCustomDocumentationElement)
            val tailwindClass = element?.getUserData(TAILWIND_CLASS_KEY)
            if (tailwindClass != null) {
                this.logger.info("Found Tailwind class in user data: $tailwindClass")
                val doc = generateDocForClass(tailwindClass, element.project)
                this.logger.info("Generated doc for Tailwind class: ${doc != null}")
                return doc ?: "<html><body>No documentation available for: $tailwindClass</body></html>"
            }
            
            // Try to extract class name from the element
            val className = extractClassName(element, originalElement)
            
            // Direct logging for debugging
            this.logger.info("Extracted class name: $className")
            
            if (className.isNullOrBlank()) {
                this.logger.info("Could not extract class name")
                // Try using the text directly as a fallback
                val directText = element.text?.trim()?.takeIf { it.isNotBlank() }
                if (directText != null && !directText.contains(" ") && isTailwindPattern(directText, element.project)) {
                    this.logger.info("Using direct element text as fallback: $directText")
                    return generateDocForClass(directText, element.project)
                }
                return null
                return generateDocForClass(className, project)
            } else {
                // Not a Tailwind class, let other providers handle it
                this.logger.info("Not a Tailwind class: $className")
                return null
            }
        } catch (e: Exception) {
            this.logger.error("Error in generateTailwindDoc: ${e.message}")
            e.printStackTrace()
            // En dernier recours, tenter de g√©n√©rer une documentation basique
            return element.text?.let { generateBasicDocumentation(it, element.project) }
        }
    }
    
    /**
     * Helper method to generate documentation for a Tailwind class
     */
    private fun generateDocForClass(className: String, project: Project): String? {
        this.logger.info("\n=== generateDocForClass ===")
        this.logger.info("Class name: $className")
        this.logger.info("Project: ${project.name}")
        
        if (className.isBlank()) {
            this.logger.info("Class name is blank, returning null")
            return "<html><body>No class name provided</body></html>"
        }
        
        // Clean up the class name
        val cleanClassName = className.trim()
        if (cleanClassName.isEmpty()) {
            this.logger.info("Class name is empty after trimming, returning null")

    // Check for arbitrary values like w-[100px]
    if (className.contains("[") && className.contains("]")) {
        logger.info("Matched arbitrary value pattern: $className")
        return true
    }

    // Define common Tailwind prefixes
    val tailwindPrefixes = listOf(
        // Layout
        "container", "block", "inline-block", "inline", "flex", "inline-flex", "grid", "inline-grid", "table",
        "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group",
        "table-row-group", "table-row", "flow-root", "hidden", "float-", "clear-", "object-", "overflow-",
        "overscroll-", "static", "fixed", "absolute", "relative", "sticky", "inset-", "top-", "right-", "bottom-",
        "left-", "z-", "order-", "col-", "row-", "col-start-", "col-end-", "row-start-", "row-end-", "grid-cols-",
        "grid-rows-", "auto-cols-", "auto-rows-", "gap-", "gap-x-", "gap-y-", "justify-items-", "justify-self-",
        "justify-", "content-", "items-", "self-", "place-content-", "place-items-", "place-self-", "p-", "px-", "py-",
        "pt-", "pr-", "pb-", "pl-", "m-", "mx-", "my-", "mt-", "mr-", "mb-", "ml-", "space-x-", "space-y-", "w-", "min-w-",
        "max-w-", "h-", "min-h-", "max-h-", "font-", "text-", "antialiased", "subpixel-antialiased", "italic",
        "not-italic", "normal-nums", "ordinal", "slashed-zero", "lining-nums", "oldstyle-nums", "proportional-nums",
        "tabular-nums", "diagonal-fractions", "stacked-fractions", "tracking-", "leading-", "list-", "list-inside",
        "list-outside", "placeholder-", "placeholder-opacity-", "align-", "whitespace-", "break-", "truncate",
        "overflow-", "overflow-x-", "overflow-y-", "overscroll-", "overscroll-x-", "overscroll-y-", "scrolling-",
        "bg-", "bg-opacity-", "bg-blend-", "from-", "via-", "to-", "gradient-", "border-", "border-opacity-",
        "rounded-", "rounded-t-", "rounded-r-", "rounded-b-", "rounded-l-", "rounded-tl-", "rounded-tr-",
        "rounded-br-", "rounded-bl-", "divide-", "divide-opacity-", "ring-", "ring-opacity-", "ring-offset-",
        "shadow-", "opacity-", "mix-blend-", "bg-blend-", "filter", "filter-none", "backdrop-filter",
        "backdrop-filter-none", "transition-", "duration-", "ease-", "delay-", "animate-", "transform",
        "transform-gpu", "transform-none", "origin-", "scale-", "scale-x-", "scale-y-", "rotate-", "translate-x-",
        "translate-y-", "skew-x-", "skew-y-", "cursor-", "select-", "resize-", "appearance-none", "outline-none",
        "sr-only", "not-sr-only"
    )

    // Define Tailwind variants
    val tailwindVariants = listOf(
        // Responsive variants
        "sm:", "md:", "lg:", "xl:", "2xl:", "max-sm:", "max-md:", "max-lg:", "max-xl:", "max-2xl:",
        // Pseudo-class variants
        "hover:", "focus:", "focus-within:", "focus-visible:", "active:", "visited:", "target:", "first:", "last:",
        "only:", "odd:", "even:", "first-of-type:", "last-of-type:", "only-of-type:", "checked:", "disabled:",
        "enabled:", "required:", "invalid:", "valid:", "placeholder-shown:", "autofill:", "read-only:",
        "before:", "after:", "first-letter:", "first-line:", "marker:", "selection:", "file:", "backdrop:",
        // Group variants
        "group:", "group-hover:", "group-focus:", "group-focus-within:", "group-active:", "group-visited:",
        "group-disabled:", "group-checked:", "group-focus-visible:",
        // Peer variants
        "peer:", "peer-hover:", "peer-focus:", "peer-focus-within:", "peer-active:", "peer-visited:",
        "peer-disabled:", "peer-checked:", "peer-focus-visible:",
        // Dark mode
        "dark:", "light:",
        // Reduced motion
        "motion-safe:", "motion-reduce:",
        // Print
        "print:",
        // RTL/LTR
        "rtl:", "ltr:",
        // Open/closed states
        "open:",
        // Form validation
        "valid:", "invalid:", "in-range:", "out-of-range:", "required:", "optional:",
        // ARIA states
        "aria-checked:", "aria-disabled:", "aria-expanded:", "aria-hidden:", "aria-pressed:", "aria-selected:",
        "aria-busy:", "aria-checked:", "aria-current:", "aria-grabbed:", "aria-haspopup:", "aria-invalid:",
        "aria-modal:", "aria-multiline:", "aria-multiselectable:", "aria-pressed:", "aria-readonly:", "aria-required:",
        "aria-selected:", "aria-valuemax:", "aria-valuemin:", "aria-valuenow:", "aria-valuetext:",
        // Data attribute variants
        "data-\\[.*\\]:"
    )

    // Check for variants + prefix patterns
    for (variant in tailwindVariants) {
        if (className.startsWith(variant)) {
            val baseClass = className.substring(variant.length)
            // If the base class is empty after removing variant, it's likely a variant for a parent
            if (baseClass.isEmpty()) {
                logger.info("Found variant with empty base class: $variant")
                return true
            }

            // Check if the base class matches any prefix
            val prefixMatched = tailwindPrefixes.any { prefix ->
                baseClass == prefix ||
                (prefix.endsWith("-") && baseClass.startsWith(prefix)) ||
                (!prefix.endsWith("-") && baseClass == prefix)
        logger.info("Finding class at cursor. Text length: ${text.length}, Cursor offset: $cursorOffset")
        
        if (text.isBlank()) {
            logger.info("Empty text provided to findClassAtCursor")
            return null
        }
        
        // If this is a simple single class, return it immediately
        if (!text.contains(" ") && !text.contains("\n")) {
            logger.info("Simple single class found: $text")
            return text
        }
        
        try {
            // Handle quoted strings by removing quotes
            val cleanText = text.trim().removeSurrounding("\"").removeSurrounding("'")
            
            // Handle edge cases with cursor position
            var adjustedOffset = cursorOffset
            
            // Adjust for quotes
            if (text != cleanText && (text.startsWith("\"") || text.startsWith("'"))) {
                adjustedOffset = adjustedOffset - 1
            }
            
            // Safety check for cursor position
            adjustedOffset = adjustedOffset.coerceIn(0, cleanText.length)
            
            // Debug info
            logger.info("Clean text: '$cleanText', adjusted offset: $adjustedOffset")
            
            // Fast path for single class
            if (!cleanText.contains(" ")) {
                logger.info("Single class detected: $cleanText")
                return cleanText
            }
            
            // Split by any whitespace (including multiple spaces, tabs, etc.)
            val classes = cleanText.split(Regex("\\s+"))
            logger.info("Found ${classes.size} classes in text: ${classes.joinToString(", ")}")
            
            // If there's only one class, return it regardless of cursor position
            if (classes.size == 1 && classes[0].isNotEmpty()) {
                logger.info("Single class returned: ${classes[0]}")
                return classes[0]
            }
            
            var currentPosition = 0
            
            for (className in classes) {
                if (className.isEmpty()) {
                    currentPosition++
                    continue
                }
                
                // Find exact position of this class in the original text
                val start = cleanText.indexOf(className, currentPosition)
                if (start == -1) {
                    logger.info("Could not find class '$className' at position $currentPosition")
                    continue
                }
                
                val end = start + className.length
                
                logger.info("Class: $className, Start: $start, End: $end, Cursor: $adjustedOffset")
                
                // Check if cursor is within or at the boundaries of this class
                if (adjustedOffset >= start && adjustedOffset <= end) {
                    logger.info("Found class at cursor: $className")
                    return className
                }
                
                currentPosition = end + 1 // Skip past this class and the following space
            }
            
            logger.info("No class found at cursor position $adjustedOffset")
            return null
            
        } catch (e: Exception) {
            logger.error("Error finding class at cursor", e)
            return null
        }
    }
    
    /**
     * Generate basic documentation for classes that don't have specific data
     */
    private fun generateBasicDocumentation(className: String, project: Project): String {
        logger.info("Generating basic documentation for class: $className")
        
        // Extract prefix and value from class name
        val (prefix, value) = extractPrefixAndValue(className)
        logger.info("Extracted prefix: '$prefix', value: '$value'")
        
        // Get category icon
        val categoryIcon = getCategoryIcon(prefix)
        
        // Get description based on prefix
        val description = getDescriptionForPrefix(prefix, value)
        
        // Infer CSS properties
        val cssProps = inferCssProperties(className)
        val cssHtml = if (cssProps.isNotEmpty()) {
            val cssLines = StringBuilder()
            cssProps.forEach { (prop, value) ->
                cssLines.append("&nbsp;&nbsp;<span style=\"color: #07a;\">$prop</span>: <span style=\"color: #a67\">$value</span>;<br/>\n")
            }
            
            """
            <div style="margin-top: 10px; padding: 10px; background-color: #f8f8f8; border-radius: 4px; font-family: monospace;">
                <div style="color: #666; font-weight: bold;">Inferred CSS:</div>
                <div style="margin-top: 5px; color: #333;">
                    <span style="color: #905;">.${className}</span> {<br/>
                    $cssLines
                    }
                </div>
            </div>
            """
        } else ""
        
        // Check for responsive or state variants
        val variantHtml = if (className.contains(":")) {
            val parts = className.split(":")
            val variant = parts.first()
            val baseClass = parts.last()
            
            val variantDescription = when (variant) {
                "hover" -> "Applied when the element is hovered"
                "focus" -> "Applied when the element has focus"
                "active" -> "Applied when the element is active"
                "disabled" -> "Applied when the element is disabled"
                "sm" -> "Applied at small screen sizes (640px and above)"
                "md" -> "Applied at medium screen sizes (768px and above)"
                "lg" -> "Applied at large screen sizes (1024px and above)"
                "xl" -> "Applied at extra large screen sizes (1280px and above)"
                "2xl" -> "Applied at 2x extra large screen sizes (1536px and above)"
                "dark" -> "Applied in dark mode"
                else -> "Applied in $variant state"
            }
            
            """
            <div style="margin-top: 12px; padding: 8px; background-color: #f0f9ff; border-radius: 4px; border-left: 3px solid #3b82f6;">
                <div style="font-weight: bold;">Variant: <code>$variant</code></div>
                <div style="margin-top: 4px;">$variantDescription</div>
                <div style="margin-top: 4px;">Base class: <code>$baseClass</code></div>
            </div>
            """
        } else ""
        
        // Add tailwind version badge if applicable
        val versionInfo = if (isTailwindV4Class(className)) {
            """
            <div style="display: inline-block; margin-left: 8px; padding: 2px 8px; background-color: #0ea5e9; color: white; font-size: 12px; border-radius: 12px;">
                Tailwind v4
            </div>
            """
        } else ""
        
        return """
            <html>
                <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', sans-serif;">
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <span style="font-size: 16px; margin-right: 8px;">$categoryIcon</span>
                        <span style="font-size: 16px; font-weight: bold;">$className</span>
                        $versionInfo
                    </div>
                    <div style="margin-bottom: 10px; color: #374151;">
                        <span><i>$description</i></span>
                    </div>
                    $cssHtml
                    $variantHtml
                </body>
            </html>
        """.trimIndent()
    }
    
    /**
     * Extract the prefix and value from a Tailwind class name
     */
    private fun extractPrefixAndValue(className: String): Pair<String, String> {
        // Handle variant prefixes (e.g., hover:, focus:, md:)
        val baseClass = if (className.contains(":")) {
            className.split(":").last()
        } else {
            className
        }
        
        // Match common patterns like bg-red-500, w-1/2, text-sm, etc.
        val regex = Regex("([\\w-]+)[-/](.+)")
        val matchResult = regex.find(baseClass)
        
        return if (matchResult != null) {
            val (prefix, value) = matchResult.destructured
            Pair(prefix, value)
        } else {
            // For classes without a clear separator (e.g., flex, hidden)
            Pair(baseClass, "")
        }
    }
    
    /**
     * Generate an appropriate icon for a category
     */
    private fun getCategoryIcon(prefix: String): String {
        return when (prefix) {
            "bg" -> "üé®" // Background
            "text" -> "üî§" // Text
            "font" -> "üìù" // Font
            "m", "p", "mt", "mb", "ml", "mr", "mx", "my", 
            "pt", "pb", "pl", "pr", "px", "py" -> "üìè" // Spacing
            "w", "h", "min-w", "min-h", "max-w", "max-h" -> "üìê" // Width/Height
            "border" -> "üî≤" // Border
            "rounded" -> "‚ö™" // Rounded
            "flex", "grid" -> "üß©" // Layout
            "justify", "items", "content" -> "‚ÜîÔ∏è" // Alignment
            "shadow" -> "üë•" // Shadow
            "opacity" -> "üå´Ô∏è" // Opacity
            "z" -> "üî¢" // Z-index
            "overflow" -> "üì¶" // Overflow
            "transition" -> "üîÑ" // Transition
            "animate" -> "‚ú®" // Animation
            "transform", "rotate", "scale", "translate" -> "üîÑ" // Transform
            "cursor" -> "üëÜ" // Cursor
            "select" -> "‚úì" // Selection
            "outline" -> "‚úíÔ∏è" // Outline
            "ring" -> "‚≠ï" // Ring/Focus
            "filter" -> "üîç" // Filter
            "backdrop" -> "üñºÔ∏è" // Backdrop
            "table" -> "üèì" // Table
            "object" -> "üñºÔ∏è" // Object-fit/position
            "mix" -> "üé≠" // Mix blend
            else -> "üß∞" // General utilities
        }
    }
    
    /**
     * Get description based on the prefix
     */
    private fun getDescriptionForPrefix(prefix: String, value: String): String {
        return when (prefix) {
            "bg" -> "Sets the background color to ${prettifyValue(value)}"
            "text" -> if (value.matches(Regex("\\w+\\d+"))) {
                "Sets the text color to ${prettifyValue(value)}"
            } else {
                "Sets the text size to ${prettifyValue(value)}"
            }
            "font" -> "Sets the font family or weight to ${prettifyValue(value)}"
            "m", "margin" -> "Sets margin on all sides to ${prettifyValue(value)}"
            "p", "padding" -> "Sets padding on all sides to ${prettifyValue(value)}"
            "mt" -> "Sets top margin to ${prettifyValue(value)}"
            "mb" -> "Sets bottom margin to ${prettifyValue(value)}"
            "ml" -> "Sets left margin to ${prettifyValue(value)}"
            "mr" -> "Sets right margin to ${prettifyValue(value)}"
            "mx" -> "Sets horizontal margin to ${prettifyValue(value)}"
            "my" -> "Sets vertical margin to ${prettifyValue(value)}"
            "pt" -> "Sets top padding to ${prettifyValue(value)}"
            "pb" -> "Sets bottom padding to ${prettifyValue(value)}"
            "pl" -> "Sets left padding to ${prettifyValue(value)}"
            "pr" -> "Sets right padding to ${prettifyValue(value)}"
            "px" -> "Sets horizontal padding to ${prettifyValue(value)}"
            "py" -> "Sets vertical padding to ${prettifyValue(value)}"
            "w" -> "Sets width to ${prettifyValue(value)}"
            "h" -> "Sets height to ${prettifyValue(value)}"
            "min-w" -> "Sets minimum width to ${prettifyValue(value)}"
            "min-h" -> "Sets minimum height to ${prettifyValue(value)}"
            "max-w" -> "Sets maximum width to ${prettifyValue(value)}"
            "max-h" -> "Sets maximum height to ${prettifyValue(value)}"
            "border" -> if (value.isEmpty()) "Adds a border with default width" else "Sets border color to ${prettifyValue(value)}"
            "border-t" -> "Adds a top border"
            "border-b" -> "Adds a bottom border"
            "border-l" -> "Adds a left border"
            "border-r" -> "Adds a right border"
            "rounded" -> if (value.isEmpty()) "Adds default border radius" else "Sets border radius to ${prettifyValue(value)}"
            "flex" -> if (value.isEmpty()) "Sets display to flex" else "Sets flex properties to ${prettifyValue(value)}"
            "grid" -> "Sets display to grid"
            "justify" -> "Sets justify-content to ${prettifyValue(value)}"
            "items" -> "Sets align-items to ${prettifyValue(value)}"
            "content" -> "Sets align-content to ${prettifyValue(value)}"
            "shadow" -> if (value.isEmpty()) "Adds default shadow" else "Sets shadow to ${prettifyValue(value)}"
            "opacity" -> "Sets opacity to ${prettifyValue(value)}"
            "z" -> "Sets z-index to ${prettifyValue(value)}"
            "overflow" -> "Sets overflow to ${prettifyValue(value)}"
            "transition" -> if (value.isEmpty()) "Adds default transition" else "Sets transition property to ${prettifyValue(value)}"
            "animate" -> "Applies animation ${prettifyValue(value)}"
            "transform" -> "Applies CSS transform"
            "rotate" -> "Rotates element by ${prettifyValue(value)}"
            "scale" -> "Scales element by ${prettifyValue(value)}"
            "translate" -> "Translates element by ${prettifyValue(value)}"
            "cursor" -> "Sets cursor to ${prettifyValue(value)}"
            "select" -> "Sets user-select to ${prettifyValue(value)}"
            "outline" -> "Controls the outline"
            "hidden" -> "Sets display to none"
            "block" -> "Sets display to block"
            "inline" -> "Sets display to inline"
            "inline-block" -> "Sets display to inline-block"
            "relative" -> "Sets position to relative"
            "absolute" -> "Sets position to absolute"
            "fixed" -> "Sets position to fixed"
            "sticky" -> "Sets position to sticky"
            else -> if (value.isEmpty()) "Tailwind utility class '$prefix'" else "Tailwind utility class '$prefix-$value'"
        }
    }
    
    /**
     * Generate error documentation to show to users when an exception occurs
     */
    private fun generateErrorDocumentation(message: String, exception: Exception? = null): String {
        val errorMessage = message.takeIf { it.isNotBlank() } ?: "An error occurred"
        
        val stackTraceHtml = exception?.let {
            val stackTrace = it.stackTraceToString()
            
            """
            <div style="margin-top: 10px;">
                <details>
                    <summary style="color: #666; cursor: pointer; font-weight: bold;">See Details</summary>
                    <div style="margin-top: 5px; padding: 10px; background-color: #f8f8f8; border-radius: 4px; font-family: monospace; font-size: 12px; white-space: pre-wrap; overflow-x: auto;">
                        ${it.message ?: ""}
                        $stackTrace
                    </div>
                </details>
            </div>
            """
        } ?: ""
        
        return """
            <html>
                <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', sans-serif;">
                    <div style="padding: 10px; background-color: #fee2e2; border-radius: 4px; border-left: 4px solid #ef4444;">
                        <div style="font-weight: bold; color: #b91c1c;">Error</div>
                        <div style="margin-top: 5px; color: #374151;">$errorMessage</div>
                        $stackTraceHtml
                    </div>
                </body>
            </html>
        """.trimIndent()
    }
    
    /**
     * Identify if a class name belongs to Tailwind v4
     */
    private fun isTailwindV4Class(className: String): Boolean {
        // This is a simplistic check - in a real implementation you might have a more comprehensive list
        val v4PrefixList = listOf(
            "plc-", // placeholder color classes
            "shadow-", // updated shadow utility
            "text-balance", // text balancing
            "text-pretty", // improved text wrapping
            "font-", // new font variants
            "size-", // size utility (replaces w-* + h-*)
            "grid-flow-", // updated grid flow utilities
            "backdrop-", // updated backdrop utilities
            "text-wrap-", // text wrapping utilities
            "columns-" // updated column utilities
        )
        
        return v4PrefixList.any { className.startsWith(it) }
    }
    
    /**
     * Get contrasting text color for a background
     */
    private fun getContrastingTextColor(backgroundColor: String): String {
        // Simple algorithm: for hex colors, calculate brightness and return white for dark backgrounds, black for light
        if (backgroundColor.startsWith("#")) {
            try {
                val hexColor = backgroundColor.substring(1)
                val r = hexColor.substring(0, 2).toInt(16)
                val g = hexColor.substring(2, 4).toInt(16)
                val b = hexColor.substring(4, 6).toInt(16)
                
                // Calculate perceived brightness using YIQ formula
                val brightness = (r * 299 + g * 587 + b * 114) / 1000
                
                return if (brightness > 128) "#000000" else "#ffffff"
            } catch (e: Exception) {
                return "#000000"
            }
        }
        
        // Fallback
        return "#000000"
    }
    
    /**
     * Extract color value from a Tailwind color class name
     */
    private fun extractColorValue(className: String): String? {
        // This is a simplified mapping - a real implementation would have a comprehensive color map
        val colorMap = mapOf(
            "red" to "#ef4444",
            "blue" to "#3b82f6",
            "green" to "#10b981",
            "yellow" to "#f59e0b",
            "purple" to "#8b5cf6",
            "pink" to "#ec4899",
            "indigo" to "#6366f1",
            "gray" to "#9ca3af",
            "white" to "#ffffff",
            "black" to "#000000"
        )
        
        // Try to match color name and shade (e.g., "bg-red-500")
        val regex = Regex("(bg|text|border)-([\\w-]+)(?:-(\\d+))?")
        val match = regex.find(className)
        
        if (match != null) {
            val colorName = match.groupValues[2]
            val shade = match.groupValues.getOrNull(3)
            
            // Return matching color or null if not found
            return colorMap[colorName]
        }
        
        return null
    }
    
    /**
     * Infer CSS properties based on the class name
     */
    private fun inferCssProperties(className: String): Map<String, String> {
        val properties = mutableMapOf<String, String>()
        val (prefix, value) = extractPrefixAndValue(className)
        
        when (prefix) {
            "bg" -> properties["background-color"] = "var(--tw-${value}, #ccc)"
            "text" -> {
                if (value.matches(Regex("\\w+\\d+"))) {
                    properties["color"] = "var(--tw-${value}, #333)"
                } else {
                    properties["font-size"] = when(value) {
                        "xs" -> "0.75rem"
                        "sm" -> "0.875rem"
                        "md" -> "1rem"
                        "lg" -> "1.125rem"
                        "xl" -> "1.25rem"
                        "2xl" -> "1.5rem"
                        "3xl" -> "1.875rem"
                        "4xl" -> "2.25rem"
                        "5xl" -> "3rem"
                        else -> value
                    }
                }
            }
            "font" -> {
                if (value.matches(Regex("\\d+"))) {
                    properties["font-weight"] = value
                } else {
                    properties["font-family"] = "var(--tw-font-${value}, sans-serif)"
                }
            }
            "w" -> properties["width"] = parseDimension(value)
            "h" -> properties["height"] = parseDimension(value)
            "m" -> properties["margin"] = parseDimension(value)
            "p" -> properties["padding"] = parseDimension(value)
            "mt" -> properties["margin-top"] = parseDimension(value)
            "mb" -> properties["margin-bottom"] = parseDimension(value)
            "ml" -> properties["margin-left"] = parseDimension(value)
            "mr" -> properties["margin-right"] = parseDimension(value)
            "mx" -> {
                properties["margin-left"] = parseDimension(value)
                properties["margin-right"] = parseDimension(value)
            }
            "my" -> {
                properties["margin-top"] = parseDimension(value)
                properties["margin-bottom"] = parseDimension(value)
            }
            "pt" -> properties["padding-top"] = parseDimension(value)
            "pb" -> properties["padding-bottom"] = parseDimension(value)
            "pl" -> properties["padding-left"] = parseDimension(value)
            "pr" -> properties["padding-right"] = parseDimension(value)
            "px" -> {
                properties["padding-left"] = parseDimension(value)
                properties["padding-right"] = parseDimension(value)
            }
            "py" -> {
                properties["padding-top"] = parseDimension(value)
                properties["padding-bottom"] = parseDimension(value)
            }
            "border" -> {
                if (value.isEmpty()) {
                    properties["border-width"] = "1px"
                    properties["border-style"] = "solid"
                } else {
                    properties["border-color"] = "var(--tw-${value}, #ccc)"
                }
            }
            "rounded" -> {
                properties["border-radius"] = if (value.isEmpty()) "0.25rem" else parseDimension(value)
            }
            "flex" -> {
                properties["display"] = "flex"
                if (value.isNotEmpty()) {
                    properties["flex"] = value
                }
            }
            "grid" -> properties["display"] = "grid"
            "justify" -> properties["justify-content"] = value
            "items" -> properties["align-items"] = value
            "shadow" -> properties["box-shadow"] = if (value.isEmpty()) "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)" else "var(--tw-shadow-${value})"
            "opacity" -> properties["opacity"] = value
            "z" -> properties["z-index"] = value
            "overflow" -> properties["overflow"] = value
            "hidden" -> properties["display"] = "none"
            "block" -> properties["display"] = "block"
            "inline" -> properties["display"] = "inline"
            "inline-block" -> properties["display"] = "inline-block"
            "relative" -> properties["position"] = "relative"
            "absolute" -> properties["position"] = "absolute"
            "fixed" -> properties["position"] = "fixed"
            "sticky" -> properties["position"] = "sticky"
        }
        
        return properties
    }
    
    /**
     * Parse dimension value
     */
    private fun parseDimension(value: String): String {
        return when {
            value.matches(Regex("\\d+")) -> "${value}px"
            value.matches(Regex("\\d+/\\d+")) -> {
                // Handle fractions like 1/2, 3/4, etc.
                val parts = value.split("/")
                val numerator = parts[0].toDoubleOrNull() ?: 1.0
                val denominator = parts[1].toDoubleOrNull() ?: 1.0
                "${(numerator / denominator) * 100}%"
            }
            value == "full" -> "100%"
            value == "screen" -> "100vh"
            value == "auto" -> "auto"
            else -> value
        }
    }
    
    /**
     * Find related Tailwind classes
     */
    private fun findRelatedClasses(className: String): List<String> {
        val (prefix, value) = extractPrefixAndValue(className)
        val related = mutableListOf<String>()
        
        // For color utilities, suggest other color utilities with same color
        if (prefix in listOf("bg", "text", "border") && value.isNotEmpty()) {
            val colorPrefixes = listOf("bg", "text", "border")
            for (p in colorPrefixes) {
                if (p != prefix) {
                    related.add("$p-$value")
                }
            }
        }
        
        // For spacing utilities, suggest related ones
        if (prefix in listOf("m", "p", "mt", "mb", "ml", "mr", "mx", "my",
                "pt", "pb", "pl", "pr", "px", "py") && value.isNotEmpty()) {
            when (prefix) {
                "m" -> related.addAll(listOf("mx-$value", "my-$value"))
                "p" -> related.addAll(listOf("px-$value", "py-$value"))
                "mx" -> related.addAll(listOf("ml-$value", "mr-$value"))
                "my" -> related.addAll(listOf("mt-$value", "mb-$value"))
                "px" -> related.addAll(listOf("pl-$value", "pr-$value"))
                "py" -> related.addAll(listOf("pt-$value", "pb-$value"))
            }
        }
        
        // For dimension utilities
        if (prefix in listOf("w", "h") && value.isNotEmpty()) {
            if (prefix == "w") related.add("h-$value")
            if (prefix == "h") related.add("w-$value")
        }
        
        return related
    }
    
    /**
     * Helper function to prettify values for display
     */
    private fun prettifyValue(value: String): String {
        return when {
            value.isEmpty() -> ""
            value == "auto" -> "auto"
            value.matches(Regex("\\d+")) -> "${value}px"
            value.matches(Regex("\\d+/\\d+")) -> {
                val parts = value.split("/")
                "${parts[0]}/${parts[1]}"
            }
            else -> value
        }
    }
}
